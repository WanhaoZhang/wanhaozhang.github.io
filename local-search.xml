<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>日志异常检测论文总结</title>
    <link href="/articles/2023/10/15/%E6%97%A5%E5%BF%97%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/"/>
    <url>/articles/2023/10/15/%E6%97%A5%E5%BF%97%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Log-based-Anomaly-Detection-based-on-EVT-Theory-with-feedback-arxiv-2023"><a href="#Log-based-Anomaly-Detection-based-on-EVT-Theory-with-feedback-arxiv-2023" class="headerlink" title="Log-based Anomaly Detection based on EVT Theory with feedback(arxiv 2023)"></a>Log-based Anomaly Detection based on EVT Theory with feedback(arxiv 2023)</h1><blockquote><p>2023年10月15日</p></blockquote><p>这篇论文是CUHK和华为云合作的日志异常检测项目，也是部署在真实华为云微服务上的，还是很实用的一篇文章。</p><p>文章所提出的trie-based detection agent, TDA，流程和Drain解析器很像，感觉应该就是针对Drain进行魔改的。</p><h2 id="ScaleAD异常检测器设计的三个目标"><a href="#ScaleAD异常检测器设计的三个目标" class="headerlink" title="ScaleAD异常检测器设计的三个目标"></a>ScaleAD异常检测器设计的三个目标</h2><ol><li><strong>高准确率</strong>，这是使用日志解析器的首要标准</li><li><strong>轻量级</strong>，为了处理大量的日志数据，需要使用尽可能少的内容资源，有效处理大量流式日志数据</li><li><strong>自适应性强</strong>，需要对不同的微服务自适应，能够在生产环境中没有干预的情况下持续运行</li></ol><h2 id="ScaleAD的框架"><a href="#ScaleAD的框架" class="headerlink" title="ScaleAD的框架"></a>ScaleAD的框架</h2><p><img src="/articles/2023/10/15/%E6%97%A5%E5%BF%97%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/fig2.png"></p><p>ScaleAD有个两个核心组成：基于Trie树的检测agent（trie-based detection agent, TDA） 和 一个专家模块「Trie树是一种经典的数据结构，又被称为单词查找树、字典树」。</p><p>如图2所示，ScaleAD有如下几个流程</p><ol><li>搜集流式日志数据，然后划分成日志会话或者日志窗口</li><li>然后TDA接收每个日志窗户的日志，并将其作为输入，为窗口内的每一条日志都生成一个异常分数。</li><li>在这个过程中TDA识别异常日志，然后把它们推送给专家模块来进一步确认，专家会反馈结果给TDA。 专家可以采取多种形式：一个on-call的工程师、包含多种规则的知识库、一个大语言模型</li></ol><h2 id="TDA的工作流程"><a href="#TDA的工作流程" class="headerlink" title="TDA的工作流程"></a>TDA的工作流程</h2><p><img src="/articles/2023/10/15/%E6%97%A5%E5%BF%97%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/fig3.png"></p><p>TDA的输入是：日志信息，输出：每条日志的异常得分</p><p>TDA包括五个步骤：日志预处理、内部节点遍历、叶子节点更新、trie更新、异常检测</p><ol><li>日志根据定义的启发式规则遍历内部节点，内部节点的设置考虑了日志信息的多种特征</li><li>目标是以粗粒度的方式把相似的日志分配到相同的叶子节点</li><li>日志到达叶子节点之后，会被分配给日志集群块，每个日志集群块共享相同的日志模板</li><li>最后，使用从日志集群块中搜集到的统计信息来进行异常检测</li></ol><h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1. 预处理"></a>1. 预处理</h3><p>对输入的一条日志，使用预先定义好的正则表达式提取IP、URL等参数部分，然后使用非字母数字分隔符（即非字母或数字的任何字符）对日志消息进行分割，对每条日志都生成日志tokens列表</p><h3 id="2-内部节点遍历"><a href="#2-内部节点遍历" class="headerlink" title="2. 内部节点遍历"></a>2. 内部节点遍历</h3><p>这里对内部节点定义了三种启发式规则</p><ol><li><strong>根据领域知识遍历：</strong> 首先日志按照显而易见的特征被分组，例如级别（例如，INFO 和 DEBUG）和组件</li><li><strong>根据最频繁的日志tokens进行遍历</strong>：因为日志中频繁出现的词更可能是模板中的常量词，因此我们在每个日志tokens中提取K(K&#x3D;3)个 最频繁的tokens作为<code>token key</code>。ScaleAD 维护一个词汇表，用于在处理日志消息时对tokens出现次数进行计数。提取<code>token key</code>时会丢弃英文停用词，以避免对不同的日志消息进行分组。</li><li><strong>根据日志tokens前缀进行遍历：</strong> 受到Drain的启发，日志开头的标记更有可能是常量，因为我们根据日志的前d个前缀token一次进行划分日志。然而有些日志可能开头是参数，所以我们使用超参数 cmax 来限制子节点的最大数量。</li></ol><h3 id="3-叶子节点更新"><a href="#3-叶子节点更新" class="headerlink" title="3. 叶子节点更新"></a>3. 叶子节点更新</h3><p>当遍历完所有的中间节点之后，一条日志最终会到达叶子节点，叶子节点然后回提取每个日志的模板，每个叶子节点包含多个日志集群块，每个日志集群块含有一个日志模板</p><p>正如图3右边所示，当一条日志到达叶子节点的时候，我们首先将它与现有的日志集群块进行匹配（完全匹配或部分匹配），如果匹配失败了，就新建一个日志集群块来包含新到的这条日志。然后根据到达的日志消息更新日志集群的关联模板。</p><p>下面我们对完全匹配、部分匹配和不匹配进行详细说明。</p><ol><li><strong>完全匹配：</strong>我们将每个日志簇的模板视为正则表达式（例如，将&lt;*&gt;替换为 ”.**?“ ）来匹配给定的日志消息。这种方法允许模板匹配更长的日志消息，即使它们包含不同长度的参数，因为正则表达式允许匹配任何长度的标记。</li><li><strong>部分匹配：</strong>接下来，如果精确匹配失败，我们进行部分匹配。具体来说，我们对模板进行tokennize，并计算模板和候选日志消息之间的 Jaccard 相似度。如果候选日志与某个日志集块对应的模板的相似度大于0.5，就认为是部分匹配，否则就是不匹配。</li><li><strong>不匹配：</strong>如果叶节点中没有日志簇可以匹配给定的日志消息，我们在叶节点中创建一个新的日志簇（例如，C j &#x3D; (Lj , tj )）。这个新日志集群的模板是日志消息本身。</li></ol><p><strong>模板更新：</strong>如果给定的日志消息与某个日志集群块的模板匹配了，我们就把这个日志的ID加入到该日志集群块的$L_i$中，然后用日志$l_i$更新模板$t_i$，具体来说，我们首先识别 $l_i$ 和 $t_i$ 共享的公共token集。接下来，我们选择在 $t_i$ 和  $l_i$ 之间具有更多token的列表。最后，我们用占位符“&lt;*&gt;”替换较长列表中不在公共token集中的任何token。然后就产生了该日志集群块的新日志模板。</p><h3 id="4-Trie更新"><a href="#4-Trie更新" class="headerlink" title="4. Trie更新"></a>4. Trie更新</h3><p>在连续流中接收到的不同日志消息可能会导致模板提取不准确，因为在积累足够数量的日志消息之前可能会生成错误模板。反过来，这会影响精确匹配步骤和部分匹配步骤的准确性，从而产生更多错误的日志集群块。</p><p>为了解决这个问题，我们提出了一种自下而上的 Trie 更新方法，将共享相同模板的日志簇合并到单个簇中，并根据合并日志簇的新模板重建 Trie。</p><aside>💡 这一步不详细记录了，就是根据匹配规则合并一些相似的日志集群块，而且我感觉这个Trie更新这一步也是在实践中发现有这么个问题，然后找到的解决方法。</aside><h3 id="5-异常检测"><a href="#5-异常检测" class="headerlink" title="5. 异常检测"></a>5. 异常检测</h3><p>再经过了Trie结构之后，日志被处理成了模板，在以往的日志异常检测中，后面还需要进行特征提取和异常检测，会有额外的计算和维护成本。为了解决这个问题，我们提出了一个与 Trie 无缝集成的轻量级异常检测模块。</p><p><strong>我们的方法旨在通过检测出现频率显着低于其他模板的模板来识别异常。「本文做异常检测的核心」</strong></p><p>我们利用极值理论（EVT）框架中的广义极值（GEV）分布，它可以<strong>有效地识别大量值中的极值</strong>。具体来说，我们枚举每个日志簇，统计每个模板的出现次数，并生成计数列表 $L_{count} &#x3D; [x1, x2, …, xR]$，其中 $x_i$ 表示第 i 个模板的计数，R 是模版的数量。接下来，我们通过拟合 GEV 分布来应用 GEV 来检测 Lcount 中的异常情况。</p><p>使用KDD17paper（Anomaly Detection in Streams with Extreme Value Theory）中的GEV分布，首先得到每个日志集群块对应模板的GEV的累计分布函数值$f(x_i)$，然后根据所有日志模板的f值，求每个模板对应的异常分数，具体来说对每个日志模板对应的f值，首先计算所有分数t次方的总和 sum，然后用 该模板的 $f(x_i)^t &#x2F; sum$，就是该模板的异常分数。</p><p>当处理大量日志模板时，在拟合 GEV 分布时，整个日志簇集的计算成本可能会很高。为了解决这个问题，我们建议使用最近最少使用（LRU）策略来限制用于拟合分布的日志模板的数量。 LRU 策略维护最近看到的日志模板的缓存，并在缓存大小达到用户定义的大小 R（如公式 2 中使用）时丢弃最近最少使用的模板。 LRU 策略基于这样的观察：通常在较短的时间间隔（例如十分钟）内仅生成一小部分日志消息。因此，我们可以关注最近看到的日志模板，这些模板可能与该时间间隔内的异常检测相关。</p><h2 id="专家模块的工作流程"><a href="#专家模块的工作流程" class="headerlink" title="专家模块的工作流程"></a>专家模块的工作流程</h2><p>比较简单，上面的异常分数大于某个阈值，就交给专家处理</p><h2 id="ScaleAD和日志解析器Drain的关系"><a href="#ScaleAD和日志解析器Drain的关系" class="headerlink" title="ScaleAD和日志解析器Drain的关系"></a>ScaleAD和日志解析器Drain的关系</h2><p><img src="/articles/2023/10/15/%E6%97%A5%E5%BF%97%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/drain.png" alt="Drain的结构"></p><p>Drain是2017年的一篇关于日志解析的文章：Drain: An Online Log Parsing Approach with Fixed Depth Tree</p><p>翻译的文章<a href="https://zhuanlan.zhihu.com/p/627345347">在这里</a></p><p>可以看到，ScaleAD类似于Drain的结构，只有几点不同</p><ol><li>ScaleAD第一层采用的是INFO这种告警等级；Drain的第一层是一个长度信息</li><li>ScaleAD采用的是日志中出现最频繁的几个词；Drain第一层的节点采用的日志长度划分</li><li>对于到达每个叶子节点的日志，Drain主要将新日志与每个日志集群块的模板匹配是按照token的相似性；而ScalAD则是先简单粗暴地用正则表达式去匹配，不成功再用token的相似度进行匹配。</li></ol>]]></content>
    
    
    <categories>
      
      <category>论文总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志异常检测</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>证书验证机制实验记录</title>
    <link href="/articles/2022/11/22/certificate-work-record/"/>
    <url>/articles/2022/11/22/certificate-work-record/</url>
    
    <content type="html"><![CDATA[<h2 id="Ubuntu搭建Nginx服务器"><a href="#Ubuntu搭建Nginx服务器" class="headerlink" title="Ubuntu搭建Nginx服务器"></a>Ubuntu搭建Nginx服务器</h2><h3 id="step1-安装-Nginx"><a href="#step1-安装-Nginx" class="headerlink" title="step1 安装 Nginx"></a>step1 安装 Nginx</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure><h3 id="step2-调整防火墙"><a href="#step2-调整防火墙" class="headerlink" title="step2 调整防火墙"></a>step2 调整防火墙</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw app list # 查看状态</span><br><span class="line">sudo ufw allow &#x27;FULL&#x27;  # 调整防火墙，让他允许 Nginx的所有服务通过</span><br><span class="line">sudo ufw status # 查看更改结果</span><br></pre></td></tr></table></figure><h3 id="step3-检查web-服务器"><a href="#step3-检查web-服务器" class="headerlink" title="step3 检查web 服务器"></a>step3 检查web 服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status nginx</span><br></pre></td></tr></table></figure><p>然后就可以使用浏览器输入 <a href="http://your_ipaddress/">http://your_ipaddress</a> 来访问了</p><h3 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx  # 重启</span><br><span class="line"></span><br><span class="line">sudo systemctl reload nginx # 修改了配置之后重新加载</span><br><span class="line"></span><br><span class="line">sudo systemctl disable nginx # 默认情况下，Nginx 会在服务器启动时，跟随系统启动，如果我们不想这样，我们可以用这个命令来禁止</span><br><span class="line"></span><br><span class="line">sudo systemctl enable nginx # 要重新让系统启动时引导 Nginx 启动</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://kalacloud.com/blog/how-to-install-nginx-on-ubuntu-20-04/">https://kalacloud.com/blog/how-to-install-nginx-on-ubuntu-20-04/</a></p><p><a href="https://developer.aliyun.com/article/759280">https://developer.aliyun.com/article/759280</a></p><h2 id="Nginx安装SSL配置HTTPS"><a href="#Nginx安装SSL配置HTTPS" class="headerlink" title="Nginx安装SSL配置HTTPS"></a>Nginx安装SSL配置HTTPS</h2><p>看下面文章的第一部分，注意在覆盖文件之前先备份，防止出错</p><p><a href="https://segmentfault.com/a/1190000022673232">nginx - Nginx 安装 SSL 配置 HTTPS 超详细完整全过程_个人文章 - SegmentFault 思否</a></p><h2 id="生成证书并部署到Nginx服务器"><a href="#生成证书并部署到Nginx服务器" class="headerlink" title="生成证书并部署到Nginx服务器"></a>生成证书并部署到Nginx服务器</h2><p>使用下面命令后会让输入一些 地区、公司名、机构名之类的信息，随便写即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//生成ca 私钥</span><br><span class="line">openssl genrsa  -out ca.key 2048 </span><br><span class="line"> </span><br><span class="line">//生成ca证书</span><br><span class="line">openssl req -x509 -new -nodes -key ca.key -sha256 -days 3650 -out ca.crt</span><br><span class="line"> </span><br><span class="line">//生成server 私钥和证书请求文件</span><br><span class="line">openssl req -new -sha256 -nodes -out server.csr -newkey rsa:2048 -keyout server.key</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建v3.ext文件</span><br><span class="line">vim v3.ext</span><br><span class="line"></span><br><span class="line">// 在v3.ext文件中写入内容，注意换成IP</span><br><span class="line">//</span><br><span class="line">    authorityKeyIdentifier = keyid, issuer</span><br><span class="line">    basicConstraints = CA:FALSE</span><br><span class="line">    keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class="line">    subjectAltName = @alt_names</span><br><span class="line">    [alt_names]</span><br><span class="line">    DNS.1 = test.cn  //使用是ip 则使用IP.1=xxxx</span><br><span class="line">//</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用ca 签发server</span><br><span class="line">openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 3650 -sha256 -extfile v3.ext</span><br></pre></td></tr></table></figure><p>Nginx 配置，一般只需要修改生成证书的位置信息即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># HTTP_TO_HTTPS_END</span><br><span class="line">#ssl_password_file /etc/nginx/conf.d/openssl/global.pass;</span><br><span class="line">    ssl_certificate       /etc/nginx/conf.d/openssl/server.crt; # 只需要改这里</span><br><span class="line">    ssl_certificate_key   /etc/nginx/conf.d/openssl/server.key; # 只需要改这里</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    ssl_session_cache shared:SSL:10m;</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line">    error_page 497  https://$host$request_uri;</span><br><span class="line"># SSL-END</span><br></pre></td></tr></table></figure><p><mark>目前，<code>203.91.121.226</code>服务器上，证书生成的位置在<code>/etc/ssl/private/下面，nginx的配置文件可以通过</code>sudo nginx -t<code>进行查看，目前在</code> &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf&#96;中 </mark></p><p>每次<strong>修改完了nginx配置文件</strong></p><ul><li>使用 <code>nginx -t</code> 检查文件是否没问题</li><li>使用<code>nginx -s  reload</code> 重新加载配置文件</li></ul><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/LCRxxoo/article/details/120674063">https://blog.csdn.net/LCRxxoo/article/details/120674063</a> 【这篇最有效果】</p><p><a href="https://www.cnblogs.com/hukey/p/16306560.html">OpenSSL自签发CA证书chrome浏览器安全访问 - hukey - 博客园 (cnblogs.com)</a></p><h2 id="将根证书导入到浏览器中使其信任"><a href="#将根证书导入到浏览器中使其信任" class="headerlink" title="将根证书导入到浏览器中使其信任"></a>将根证书导入到浏览器中使其信任</h2><p>将上诉步骤生成的ca.crt导入浏览器即可</p><h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/hukey/p/16306560.html">OpenSSL自签发CA证书chrome浏览器安全访问 - hukey - 博客园 (cnblogs.com)</a></p><h2 id="使用hosts把自定义域名映射到本地"><a href="#使用hosts把自定义域名映射到本地" class="headerlink" title="使用hosts把自定义域名映射到本地"></a>使用hosts把自定义域名映射到本地</h2><p>Windows开发环境下，打开C:\Windows\System32\drivers\etc目录下的hosts文件。添加<code>127.0.0.1 jd.com</code>，完成IP地址（127.0.0.1）和域名（jd.com）映射的配置。如果修改后无法保存，请获得管理员权限后重试。</p><h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/307d9f91eede">https://www.jianshu.com/p/307d9f91eede</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>证书机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件分析课程实验-A1-活跃变量分析和迭代求解器</title>
    <link href="/articles/2022/11/20/static-analysis-A1/"/>
    <url>/articles/2022/11/20/static-analysis-A1/</url>
    
    <content type="html"><![CDATA[<p>课程主页：<a href="https://tai-e.pascal-lab.net/lectures.html">https://tai-e.pascal-lab.net/lectures.html</a></p><h2 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h2><p>数据流分析指的是一种用来获取有关数据如何沿着程序执行路径流动的相关技术，许多编译优化技术都依赖于数据流分析。</p><p>数据流分析有很多经典的应用，比如</p><ul><li>到达定值分析</li><li>活跃变量分析</li><li>可用表达式分析</li></ul><h2 id="活跃变量分析原理"><a href="#活跃变量分析原理" class="headerlink" title="活跃变量分析原理"></a>活跃变量分析原理</h2><p>活跃变量分析（Live Variable Analysis）是<strong>数据流分析</strong>的一个经典应用</p><h3 id="活跃变量"><a href="#活跃变量" class="headerlink" title="活跃变量"></a><strong>活跃变量</strong></h3><p>对于变量$x$和程序点$p$，如果在程序流图中沿着从$p$开始的<strong>某条路径</strong>会引用变量$x$在$p$点的值，则称变量$x$在点$p$是活跃（live）的，否则称变量$x$在点$p$是不活跃（dead）的</p><h3 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a><strong>主要用途</strong></h3><ol><li>删除无用赋值：如果在某点赋值，但是后面又不会用到的话，可以将该点的赋值删除</li><li>寄存器分配：如果寄存器都被占用，则当再次申请寄存器的时候，需要替换掉一些占用寄存器的变量。通过活跃变量分析，可以将不活跃变量所占用的寄存器空出来</li></ol><h3 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a><strong>符号定义</strong></h3><p>$def_B, use_B, IN[B], OUT[B]$</p><ul><li>$def_B$ ： <strong>赋值先于任何使用</strong>的变量的集合</li><li>$use_B$：  <strong>使用先于任何赋值</strong>的变量的集合</li><li>$IN[B], OUT[B]$： 分别表示在<strong>紧靠一个基本块$B$之前和之后的点上</strong>的活跃变量的集合</li></ul><p>比如对于下面$B_2$ 的基本块中，对于 $i &#x3D; i + 1;$ 这条语句可以拆分成$t &#x3D; i + 1; i &#x3D; t;$两条指令，所以对于变量$i$而言，其使用先于任何赋值，所以属于$use_{B_2}$ 中的变量，不属于$def_{B_2}$中的变量。</p><p>另一个例子是，对于一个基本块中如果有两条指令：$v&#x3D;2; k &#x3D;  v;$ 则变量$v$的赋值先于其任何的使用，所以变量$v$属于$def_B$，而不属于 $use_B$。</p><blockquote><p>根据这些定义，$use_B$中的任何变量都必然被认为在基本块$B$的入口处是活跃的，而$def_B$中所有的变量在B的开头一定是不活跃的。</p><p>实际上，$def_b$中的成员“杀死了”某个变量可能从$B$开始成为活跃变量的任何机会</p><p>《编译原理 第二版》P390</p></blockquote><p><img src="/articles/2022/11/20/static-analysis-A1/fig2.jpg" alt="fig2"></p><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a><strong>算法原理</strong></h3><p><img src="/articles/2022/11/20/static-analysis-A1/fig3.jpg" alt="fig3"></p><ul><li>$IN[EXIT] &#x3D; \emptyset$  ： 边界条件，表示<strong>程序出口处没有变量是活跃的</strong></li><li>然后对所有除了$EXIT$ 之外的基本块 $B$ 来说，首先初始化所有$B$为空集 $IN[B] &#x3D; \emptyset$，初始化之后对所有的$B$执行如下的<strong>转移函数</strong><ul><li>$OUT[B] &#x3D; \cup _{S是B的一个后继} IN[S]$ ：一个变量在离开一个基本块的时候活跃，当且仅当它进入该基本块的<strong>某个后继</strong>时活跃</li><li>$IN[B] &#x3D; use_B \cup(OUT[B] - def_B)$ ：一个变量进入基本块的时候活跃必须保证 ，要么<strong>在基本块中被赋值之前就使用了</strong>，要么<strong>在离开基本块的时候活跃并且没有对它重新赋值</strong></li></ul></li></ul><h2 id="A1实验分析"><a href="#A1实验分析" class="headerlink" title="A1实验分析"></a>A1实验分析</h2><h3 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h3><p>本次作业需要实现一个活跃变量分析算法，抽象的算法如下图所示，具体而言，需要求出每个基本块的InFact值，里面包含该点所有的活跃变量。本次作业需要填空来完成下图的算法实现</p><p><img src="/articles/2022/11/20/static-analysis-A1/iter-alg.png" alt="Iterative Algorithm"></p><p>需要注意：</p><ul><li>本次作业的每个基本块仅含有一条指令</li><li>实验的结果最后存储在参数 <code>DataflowResult&lt;Node, Fact&gt; result</code>中</li><li>用到了Java的一些特性<ul><li>Optional特性：isPresent() 和 get()的使用</li><li>泛型特性</li></ul></li></ul><h3 id="step1-初始化基本块的-InFact和OutFact"><a href="#step1-初始化基本块的-InFact和OutFact" class="headerlink" title="step1: 初始化基本块的 InFact和OutFact"></a>step1: 初始化基本块的 InFact和OutFact</h3><p><code>pascal/taie/analysis/dataflow/analysis/LiveVariableAnalysis.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> SetFact&lt;Var&gt; <span class="title function_">newBoundaryFact</span><span class="params">(CFG&lt;Stmt&gt; cfg)</span> &#123;</span><br><span class="line">       <span class="comment">// TODO - finish me</span></span><br><span class="line">       <span class="comment">// 返回边界节点的向量，backwards的边界节点是 exit节点</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SetFact</span>&lt;Var&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> SetFact&lt;Var&gt; <span class="title function_">newInitialFact</span><span class="params">()</span> &#123;  <span class="comment">// 返回值就是 SetFact&lt;Var&gt;</span></span><br><span class="line">       <span class="comment">// TODO - finish me</span></span><br><span class="line">       <span class="comment">// 除了exit节点的其他节点初始化为空</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SetFact</span>&lt;Var&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetInto</span><span class="params">(SetFact&lt;Var&gt; fact, SetFact&lt;Var&gt; target)</span> &#123; <span class="comment">// 注意这里提示了，使用的是SetFact&lt;Var&gt;， 所以前面用的也都是Var</span></span><br><span class="line">       <span class="comment">// TODO - finish me</span></span><br><span class="line">       <span class="comment">// 并起来</span></span><br><span class="line">       target.union(fact);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>pascal/taie/analysis/dataflow/solver/Solver.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initializeBackward</span><span class="params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO - finish me</span></span><br><span class="line">    <span class="comment">// step1 将 exit节点的InFact置为空集</span></span><br><span class="line">    result.setInFact(cfg.getExit(), analysis.newBoundaryFact(cfg));</span><br><span class="line">    <span class="comment">// step2 将 除了exit节点之外的其他节点的InFact和OutFact置为空集</span></span><br><span class="line">    <span class="keyword">for</span> (Node node : cfg.getNodes()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cfg.isExit(node)) <span class="keyword">continue</span>;</span><br><span class="line">        result.setInFact(node, analysis.newInitialFact());</span><br><span class="line">        <span class="comment">// 将OutFact也置为空集</span></span><br><span class="line">        result.setOutFact(node, analysis.newInitialFact());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step2-实现迭代求解器"><a href="#step2-实现迭代求解器" class="headerlink" title="step2: 实现迭代求解器"></a>step2: 实现迭代求解器</h3><p><code>pascal/taie/analysis/dataflow/solver/IterativeSolver.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doSolveBackward</span><span class="params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO - finish me</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (changed) &#123;</span><br><span class="line">        changed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Node node : cfg.getNodes()) &#123;</span><br><span class="line">            <span class="comment">// 除了exit的Node，因为exitNode没有outFact</span></span><br><span class="line">            <span class="keyword">if</span> (cfg.isExit(node)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 求出OutFact</span></span><br><span class="line">            <span class="keyword">for</span> (Node succNode : cfg.getSuccsOf(node)) &#123;</span><br><span class="line">                analysis.meetInto(result.getInFact(succNode), result.getOutFact(node));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用outfact做转换，得到infact</span></span><br><span class="line">            <span class="comment">// 并且查看是否这个block的状态是否改变了</span></span><br><span class="line">            <span class="keyword">if</span> (analysis.transferNode(node, result.getInFact(node), result.getOutFact(node))) changed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step3-实现转换函数"><a href="#step3-实现转换函数" class="headerlink" title="step3: 实现转换函数"></a>step3: 实现转换函数</h3><p><code>pascal/taie/analysis/dataflow/analysis/LiveVariableAnalysis.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transferNode</span><span class="params">(Stmt stmt, SetFact&lt;Var&gt; in, SetFact&lt;Var&gt; out)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO - finish me</span></span><br><span class="line">    <span class="comment">// 复制outFact，求出新的inFact</span></span><br><span class="line">    SetFact&lt;Var&gt; newInFact = <span class="keyword">new</span> <span class="title class_">SetFact</span>&lt;&gt;();</span><br><span class="line">    newInFact.union(out);</span><br><span class="line">    <span class="comment">// 求出新的inFact</span></span><br><span class="line">    <span class="comment">// outFact - def</span></span><br><span class="line">    <span class="keyword">if</span> (stmt.getDef().isPresent()) &#123; <span class="comment">// 先用isPresent再用get是optional的典型用法</span></span><br><span class="line">        <span class="type">LValue</span> <span class="variable">def</span> <span class="operator">=</span> stmt.getDef().get();</span><br><span class="line">        <span class="keyword">if</span> (def <span class="keyword">instanceof</span> Var) &#123;</span><br><span class="line">            newInFact.remove((Var) def);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// (outFact - def ) + use</span></span><br><span class="line">    <span class="keyword">for</span> (RValue use : stmt.getUses()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (use <span class="keyword">instanceof</span>  Var) &#123;</span><br><span class="line">            newInFact.add((Var) use);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断inFact是否改变，并返回Boolean表示</span></span><br><span class="line">    <span class="keyword">if</span> (!newInFact.equals(in)) &#123;</span><br><span class="line">        in.set(newInFact);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>编译原理，第二版（龙书）</p><p><a href="https://leiblog.wang/%E7%BC%96%E8%AF%91%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BD%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#">超棒的博客，这个人是搞编译器的，他的博客可以看看</a></p><p><a href="https://www.jianshu.com/p/ebc1c72b881c">这个人的博客写了很多关于编译器优化的总结</a> </p><p><a href="https://liuyehcf.github.io/2017/11/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%963/">活跃变量分析 &amp; 常用表达式分析</a></p><p><a href="https://www.bilibili.com/video/BV1zW411t7YE/?vd_source=ee07a5a150ae217eba28dd2c4bd5549b">编译原理-哈工大，上面博客的课件都来自于此</a></p><p><a href="https://blog.csdn.net/weixin_43258309/article/details/104512206">数据流分析应用总结</a></p>]]></content>
    
    
    <categories>
      
      <category>静态程序分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>少就是多，慢就是快</title>
    <link href="/articles/2022/10/19/focus-on-one-thing-over-a-period-time/"/>
    <url>/articles/2022/10/19/focus-on-one-thing-over-a-period-time/</url>
    
    <content type="html"><![CDATA[<h2 id="“少就是多，慢就是快”"><a href="#“少就是多，慢就是快”" class="headerlink" title="“少就是多，慢就是快”"></a>“少就是多，慢就是快”</h2><blockquote><p> 我很喜欢这几个字。 这几个字很容易理解，但我还是解释一下：一个时间范围内，不要贪心搞很多事情，专注一个方向，足够的付出，结果自然会很”快”和很“多”。</p><p>摘抄自：<a href="https://github.com/zhuifengshaonianhanlu/pikachu">https://github.com/zhuifengshaonianhanlu/pikachu</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>摘抄</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>github+hexo博客上传图片无法显示</title>
    <link href="/articles/2022/10/17/how-to-upload-image-to-github-io/"/>
    <url>/articles/2022/10/17/how-to-upload-image-to-github-io/</url>
    
    <content type="html"><![CDATA[<p>github+hexo博客上传图片无法显示</p><p><strong>解决方法：</strong></p><ol><li>用f12查看图片的链接，发现链接是带日期的，而<code>hexo new post &quot;xxx&quot;</code>创建的md文件都是直接放到_post里面了，所以需要修改默认生成md的位置到 <code>年/月/日/xx.md</code>里面</li></ol><p>​<img src="/articles/2022/10/17/how-to-upload-image-to-github-io/image.png"></p><p>​所以将<code>_config.yml</code>中的<code>permalink</code>修改为： <code>permalink: &#39;articles/:year/:month/:day/:name/&#39;</code></p><ol start="2"><li><p>而且md插入图片的时候，不要加相对链接，直接写图片名字（虽然这样会导致本地的md文件不能现实图片）</p><p><img src="/articles/2022/10/17/how-to-upload-image-to-github-io/image-20221017165402267.png"></p></li></ol><p><strong>参考链接：</strong></p><p><a href="https://blog.csdn.net/m0_43401436/article/details/107191688">https://blog.csdn.net/m0_43401436/article/details/107191688</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>hexo+github建设个人blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
