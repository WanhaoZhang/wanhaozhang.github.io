<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SR Policy学习</title>
    <link href="/articles/2025/09/16/SR%20Policy%E5%AD%A6%E4%B9%A0/"/>
    <url>/articles/2025/09/16/SR%20Policy%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="SR协议"><a href="#SR协议" class="headerlink" title="SR协议"></a>SR协议</h2><p>SR技术可以分为两种：SR-MPLS和SRv6，控制层面实现方式类似；转发层面思想相同，转发方式不同，SR-MPLS使用<strong>MPLS标签</strong>转发，SRv6使用<strong>IPv6报文</strong>转发。</p><ul><li>segment就是标签，segment 列表就是标签栈</li></ul><h2 id="RSVP-TE"><a href="#RSVP-TE" class="headerlink" title="RSVP-TE"></a>RSVP-TE</h2><p>一般通过<strong>网络工程</strong>或者<strong>流量工程</strong>来提供SLA</p><ul><li>网络工程就是设计网络来满足业务流量需求</li><li>流量工程就是让特定流量按照网络优化目标进行转发<br>网络工程就是从硬件层面进行设计，而流量工程是从软件层面进行<br>Native IP的流量工程只能实现单跳的控制<br>流量工程就是网络</li></ul><p>是MPLS体系下流量工程的主要手段，本质上也是<strong>模拟电路交换</strong>的思路</p><ul><li>用IP模拟电路，并非基于IP进行优化</li><li>需要建立和维持全网状互联隧道</li><li>难以实现跨域</li><li>缺少对ECMP的支持，必须在源和目的地之间建立多条隧道才能实现负载分担</li><li>RSVP-TE FRR </li><li>RSVP-TE 没有解决引流问题，需要依赖自动引流、静态路由、策略路由等方式实现引流</li></ul><p>RSVP-TE出现了20多年，只有不到10%的运营商使用，而且其中大多只是为了使用<strong>快速重路由功能</strong>，很少用RSVP-TE进行<strong>流量调度和带宽管理控制</strong></p><blockquote><p>RSVP-TE 原理是什么？为什么本质是模拟电路交换的思路</p></blockquote><h2 id="SR-TE"><a href="#SR-TE" class="headerlink" title="SR-TE"></a>SR-TE</h2><p>SR-TE是SR的一个关键功能，SR-TE<strong>将用户的意图转换为Segment列表</strong>，然后将Segment列表编程到边缘设备上，同时引导流量到Segment列表所对应的路径上，从而实现“基于意图的网络”</p><p>SR-TE最初实现采用了<strong>隧道接口体系</strong>，由于这个隧道接口也是继承自RSVP-TE的实现，这个体系下的SR-TE存在明显的不足：</p><ul><li>隧道接口和引流是分开实现的，引流方式麻烦</li><li>需要预先配置隧道，如果无法明确隧道终点，只能部署全网状的隧道</li><li>使用了RSVP-TE的电路算法，只能使用Adj-SID编码路径，无法使用prefix-SID编码，从而导致不能使用IP ECMP，并且造成Segment路径过长</li><li>隧道接口占用了设备上的逻辑资源</li><li>不支持一些新的SR功能，如Flex-Algo</li></ul><blockquote><p>隧道接口体系是什么？<br>引流是什么？<br>IP ECMP是什么功能，为什么不支持ECMP会有很大的问题<br>Adj-SID和Prefix-SID的区别是什么，prefix-SID更好吗？</p></blockquote><p>然后为了解决传统隧道接口体系存在的问题，并且为SR-TE的后续创新打下更坚实的基础，思科在2017年提出了全新的SR-TE体系，就是SR Policy，SR Policy通过使用<strong>Segment列表</strong>而不是隧道接口，</p><p>SR Policy由三元组组成：头端（headend）、颜色（color）、端点（Endpoint），其中颜色是SR Policy的重要属性，代表的是业务意图（比如低时延、低成本并且排除SRLG）。<br>同时基于SR Policy 的SR-TE<strong>将BGP路由作为解决方案的核心</strong>：通过对业务路由进行着色，从而实现自动生成SR Policy 和 自动引流至SR Policy。</p><ul><li>基于颜色模板和端点动态地生成SR Policy，称之为按<strong>需下一条（On Demand Next-hop，ODN）</strong></li><li>将BGP路由安装到SR Policy上称之为<strong>自动引流（Autosteering）</strong></li><li>SR Policy还集成了性能测量、OAM、计数器和遥测等功能</li></ul><p>SR Policy适用于SR的不同实现：SR-MPLS和SRv6</p><blockquote><p>BGP路由染色是什么？我看到SR Policy中也有颜色，这两个之间是什么联系和区别？<br>ODN、自动引流分别是什么？干什么用的，自动引流和BGP是什么关系？</p></blockquote><h2 id="SR-Policy-原理"><a href="#SR-Policy-原理" class="headerlink" title="SR Policy 原理"></a>SR Policy 原理</h2><h3 id="SR-Policy的模型概述"><a href="#SR-Policy的模型概述" class="headerlink" title="SR Policy的模型概述"></a>SR Policy的模型概述</h3><ol><li>SR Policy由（头端、颜色、端点）三元组表示，给定头端节点，SR Policy由（颜色、端点）二元组表示</li><li>SR Policy有<strong>多条候选路径</strong>，每条候选路径都有一个偏好值（preference），这个值越高越优先选择，其中<strong>最高偏好值的有效候选路径</strong>是<strong>活动候选路径</strong>。</li><li>Segment列表：表示的是活动路径的Segment列表，<strong>每条候选路径有一个或者多个候选Segment列表</strong>，每个Segment列表有关联的负载均衡权重。作用就是，当流量引导到这条路径之后，可以根据不同的候选Segment列表的权重进行负载均衡。 </li><li>在SR-MPLS中，Segment是MPLS标签，Segment列表是MPLS标签栈</li></ol><p><img src="/articles/2025/09/16/SR%20Policy%E5%AD%A6%E4%B9%A0/image.png" alt="alt text"></p><h4 id="候选路径"><a href="#候选路径" class="headerlink" title="候选路径"></a>候选路径</h4><ol><li>候选路径分为（1）显式候选路径、（2）动态候选路径：<ul><li><p>显式候选路径是程序员或者控制器计算出候选路径，并且向头结点<strong>显式地告知要使用的路径</strong></p></li><li><p>动态候选路径则<strong>由操作员或者应用简单地表达意图</strong>（比如需要一条低时延的路径），然后头端节点（没错，头端节点也可以算路径）或者控制器将意图动态转换成Segment列表，并且按<strong>需更新Segment列表</strong>以动态响应任意的网络变化；</p><ul><li><strong>计算路径需要两个必要元素</strong>：（1）包含网络所有必要信息的数据库、（2）在这些信息上利用算法解决最优化问题的计算引擎。其中，计算引擎的核心是SR原生算法，该算法y以<strong>大限度利用ECMP</strong>和<strong>使用尽可能少的Segment</strong>为宗旨</li></ul></li></ul></li><li>每条候选路径可以通过不同的方式得到，比如本地配置、PCEP、BGP等。而活动路径则根据候选路径的<strong>有效性和偏好值</strong>选择（选择候选路径中有效并且偏好值最大的作为活动路径）</li></ol><h4 id="BSID-Binding-SID"><a href="#BSID-Binding-SID" class="headerlink" title="BSID(Binding-SID)"></a>BSID(Binding-SID)</h4><p>BSID是候选路径的一个属性，<strong>SR-Policy</strong>的BSID是<strong>活动候选路径的BSID</strong></p><p>BSID的作用：</p><ul><li>头端将BSID绑定到对应的SR Policy，并将SR Policy作为BSID的</li></ul><h4 id="失效及回退"><a href="#失效及回退" class="headerlink" title="失效及回退"></a>失效及回退</h4><ul><li>当SR Policy的候选路径没有有效的Segment列表，则此条候选路径失效；当SR Policy所有候选路径失效，则此SR Policy变为无效。</li></ul><blockquote><p>BSID的作用是什么还是没搞清楚</p></blockquote><h3 id="SR原生算法"><a href="#SR原生算法" class="headerlink" title="SR原生算法"></a>SR原生算法</h3><ul><li><strong>RSVP-TE</strong>及<strong>大多数基于隧道接口体系实现的SR-TE</strong>都是基于电路的方式计算和编码路径；而SR Policy是完全基于IP并且针对IP优化的。</li></ul><p><img src="/articles/2025/09/16/SR%20Policy%E5%AD%A6%E4%B9%A0/image-1.png" alt="alt text"></p><ul><li>左边电路算法：采用<strong>路径沿途节点的 Adj-SID 编码路径</strong>，<strong>无法利用 IP 网络中大量存在的 ECMP</strong>，效率低下；而且 Segment 列表长，很多传统设备或者低端设备无法支持。</li><li>右边的 SR 原生算法：<strong>最大化 ECMP 且最小化Segment 列表长度</strong>，因此大大提高了流量转发效率，也易于在现网部署。</li></ul><h3 id="自动引流（）"><a href="#自动引流（）" class="headerlink" title="自动引流（）"></a>自动引流（）</h3><p>自动引流的核心：标记</p><ul><li>出口PE通告BGP业务路由时（或者入口的PE接受路由时），<strong>对路由进行着色</strong>，用于表示业务路由所需的SLA</li><li><strong>头端点接收到已经着色的业务路由</strong>时，验证：**BGP路由的下一跳 (Next-Hop) + 颜色 (Color) &#x3D;&#x3D; SR Policy 的端点 (Endpoint) + 颜色 (Color)**，则BGP安装这个路由，并将其解析到SR Policy的BSID</li></ul><p><img src="/articles/2025/09/16/SR%20Policy%E5%AD%A6%E4%B9%A0/image-2.png" alt="alt text"></p><p>上图的具体流程：</p><blockquote><p>来自Gemini</p></blockquote><ol><li><p>**路由发布 (箭头①和②)**：</p><ul><li>最右边的Acme公司网络通过它的出口路由器CE42，使用BGP协议向网络运营商的边界路由器（节点4）发布了一条路由：<code>2.2.2.0/24</code>。</li><li>在发布时，这条路由被赋予了<strong>颜色30（绿色）</strong>，并且指定了下一跳地址是<code>1.1.1.4</code>（也就是节点4的地址）。</li></ul></li><li><p>**路由在网络内传递 (BGP)**：</p><ul><li>节点4收到这条BGP路由后，继续在网络内部通过BGP协议传递给其他路由器，最终传递到了入口节点1。</li></ul></li><li><p>**入口节点决策 (箭头③)**：</p><ul><li>节点1在自己的路由信息库（RIB&#x2F;FIB）中收到了这条关于 <code>2.2.2.0/24</code> 的BGP路由。</li><li>它分析这条路由信息，提取出两个关键点：下一跳是 <code>1.1.1.4</code>，颜色是 <code>30</code>。</li><li>节点1在本地查找已经配置好的SR Policy，找到了一个名为“SR Policy GREEN”的策略，其端点是 <code>1.1.1.4</code>，颜色也是 <code>30</code>。</li><li><strong>匹配成功！</strong> 节点1将这条BGP路由与SR Policy GREEN绑定。</li></ul></li><li><p>**数据转发 (绿色虚线路径)**：</p><ul><li>现在，当Acme公司的另一端（比如节点12后面的网络）有数据要发送给 <code>2.2.2.0/24</code> 时，数据包会先到达节点1。</li><li>节点1会查找自己的转发表，发现去往 <code>2.2.2.0/24</code> 的流量已经被策略绑定了。</li><li>于是，节点1会将这个数据包封装进“SR Policy GREEN”所指定的路径。这条路径是预先计算好的，例如图中所示的 <code>1 -&gt; 2 -&gt; 3 -&gt; 4</code>。</li><li>数据包就会沿着这条绿色虚线路径被精确地转发，最终到达端点4，再由节点4发往最终目的地。</li></ul></li></ol><p>总结核心步骤：</p><blockquote><p>来自Gemini</p></blockquote><ol><li><p><strong>BGP通告路由并携带“颜色”</strong>：</p><ul><li>在图的右侧，路由器CE42通过BGP协议向节点4通告了路由 <code>2.2.2.0/24</code>。</li><li>在通告这条路由时，它附加了一个特殊属性：“颜色30（绿色）”。这个动作就像是发快递时，在包裹上贴了一个“加急”的标签。</li></ul></li><li><p><strong>入口节点（头端）进行匹配和引流</strong>：</p><ul><li>当节点1（网络的入口，也叫“头端”）收到了这条携带“颜色”的BGP路由信息后，它会检查自己本地有没有预先配置好的SR Policy能与之匹配。</li><li>匹配规则是：**BGP路由的下一跳 (Next-Hop) + 颜色 (Color) &#x3D;&#x3D; SR Policy 的端点 (Endpoint) + 颜色 (Color)**。</li></ul></li><li><p><strong>触发自动引流</strong>：</p><ul><li>在图中，节点1发现：<ul><li>BGP路由 <code>2.2.2.0/24</code> 的下一跳是 <code>1.1.1.4</code>。</li><li>BGP路由的颜色是 <code>30</code>（绿色）。</li></ul></li><li>这恰好与本地配置的“SR Policy GREEN”的端点 <code>1.1.1.4</code> 和颜色 <code>30</code>（绿色）完全匹配！</li><li>匹配成功后，“自动引流”就被触发了。节点1决定，之后所有要发往 <code>2.2.2.0/24</code> 的流量，都不能走普通路由，而是必须封装到“SR Policy GREEN”这条预设的路径里去。</li></ul></li></ol><h3 id="按需下一跳（ODN）"><a href="#按需下一跳（ODN）" class="headerlink" title="按需下一跳（ODN）"></a>按需下一跳（ODN）</h3><h3 id="灵活算法（Flex-Algo）"><a href="#灵活算法（Flex-Algo）" class="headerlink" title="灵活算法（Flex-Algo）"></a>灵活算法（Flex-Algo）</h3><h3 id="网络切片"><a href="#网络切片" class="headerlink" title="网络切片"></a>网络切片</h3><h3 id="性能测量"><a href="#性能测量" class="headerlink" title="性能测量"></a>性能测量</h3><h2 id="SR-Policy技术实现"><a href="#SR-Policy技术实现" class="headerlink" title="SR Policy技术实现"></a>SR Policy技术实现</h2><h2 id="SR-Policy典型应用场景"><a href="#SR-Policy典型应用场景" class="headerlink" title="SR Policy典型应用场景"></a>SR Policy典型应用场景</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.cisco.com/c/dam/global/zh_cn/solutions/service-provider/segment-routing/pdf/new_generation_segment_routing_sr_policy.pdf">新一代 Segment Routing 流量工程体系 - SR Policy</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SR Policy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日志异常检测论文总结</title>
    <link href="/articles/2023/10/15/%E6%97%A5%E5%BF%97%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/"/>
    <url>/articles/2023/10/15/%E6%97%A5%E5%BF%97%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Log-based-Anomaly-Detection-based-on-EVT-Theory-with-feedback-arxiv-2023"><a href="#Log-based-Anomaly-Detection-based-on-EVT-Theory-with-feedback-arxiv-2023" class="headerlink" title="Log-based Anomaly Detection based on EVT Theory with feedback(arxiv 2023)"></a>Log-based Anomaly Detection based on EVT Theory with feedback(arxiv 2023)</h1><blockquote><p>2023年10月15日</p></blockquote><p>这篇论文是CUHK和华为云合作的日志异常检测项目，也是部署在真实华为云微服务上的，还是很实用的一篇文章。</p><p>文章所提出的trie-based detection agent, TDA，流程和Drain解析器很像，感觉应该就是针对Drain进行魔改的。</p><h2 id="ScaleAD异常检测器设计的三个目标"><a href="#ScaleAD异常检测器设计的三个目标" class="headerlink" title="ScaleAD异常检测器设计的三个目标"></a>ScaleAD异常检测器设计的三个目标</h2><ol><li><strong>高准确率</strong>，这是使用日志解析器的首要标准</li><li><strong>轻量级</strong>，为了处理大量的日志数据，需要使用尽可能少的内容资源，有效处理大量流式日志数据</li><li><strong>自适应性强</strong>，需要对不同的微服务自适应，能够在生产环境中没有干预的情况下持续运行</li></ol><h2 id="ScaleAD的框架"><a href="#ScaleAD的框架" class="headerlink" title="ScaleAD的框架"></a>ScaleAD的框架</h2><p><img src="/articles/2023/10/15/%E6%97%A5%E5%BF%97%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/fig2.png"></p><p>ScaleAD有个两个核心组成：基于Trie树的检测agent（trie-based detection agent, TDA） 和 一个专家模块「Trie树是一种经典的数据结构，又被称为单词查找树、字典树」。</p><p>如图2所示，ScaleAD有如下几个流程</p><ol><li>搜集流式日志数据，然后划分成日志会话或者日志窗口</li><li>然后TDA接收每个日志窗户的日志，并将其作为输入，为窗口内的每一条日志都生成一个异常分数。</li><li>在这个过程中TDA识别异常日志，然后把它们推送给专家模块来进一步确认，专家会反馈结果给TDA。 专家可以采取多种形式：一个on-call的工程师、包含多种规则的知识库、一个大语言模型</li></ol><h2 id="TDA的工作流程"><a href="#TDA的工作流程" class="headerlink" title="TDA的工作流程"></a>TDA的工作流程</h2><p><img src="/articles/2023/10/15/%E6%97%A5%E5%BF%97%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/fig3.png"></p><p>TDA的输入是：日志信息，输出：每条日志的异常得分</p><p>TDA包括五个步骤：日志预处理、内部节点遍历、叶子节点更新、trie更新、异常检测</p><ol><li>日志根据定义的启发式规则遍历内部节点，内部节点的设置考虑了日志信息的多种特征</li><li>目标是以粗粒度的方式把相似的日志分配到相同的叶子节点</li><li>日志到达叶子节点之后，会被分配给日志集群块，每个日志集群块共享相同的日志模板</li><li>最后，使用从日志集群块中搜集到的统计信息来进行异常检测</li></ol><h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1. 预处理"></a>1. 预处理</h3><p>对输入的一条日志，使用预先定义好的正则表达式提取IP、URL等参数部分，然后使用非字母数字分隔符（即非字母或数字的任何字符）对日志消息进行分割，对每条日志都生成日志tokens列表</p><h3 id="2-内部节点遍历"><a href="#2-内部节点遍历" class="headerlink" title="2. 内部节点遍历"></a>2. 内部节点遍历</h3><p>这里对内部节点定义了三种启发式规则</p><ol><li><strong>根据领域知识遍历：</strong> 首先日志按照显而易见的特征被分组，例如级别（例如，INFO 和 DEBUG）和组件</li><li><strong>根据最频繁的日志tokens进行遍历</strong>：因为日志中频繁出现的词更可能是模板中的常量词，因此我们在每个日志tokens中提取K(K&#x3D;3)个 最频繁的tokens作为<code>token key</code>。ScaleAD 维护一个词汇表，用于在处理日志消息时对tokens出现次数进行计数。提取<code>token key</code>时会丢弃英文停用词，以避免对不同的日志消息进行分组。</li><li><strong>根据日志tokens前缀进行遍历：</strong> 受到Drain的启发，日志开头的标记更有可能是常量，因为我们根据日志的前d个前缀token一次进行划分日志。然而有些日志可能开头是参数，所以我们使用超参数 cmax 来限制子节点的最大数量。</li></ol><h3 id="3-叶子节点更新"><a href="#3-叶子节点更新" class="headerlink" title="3. 叶子节点更新"></a>3. 叶子节点更新</h3><p>当遍历完所有的中间节点之后，一条日志最终会到达叶子节点，叶子节点然后回提取每个日志的模板，每个叶子节点包含多个日志集群块，每个日志集群块含有一个日志模板</p><p>正如图3右边所示，当一条日志到达叶子节点的时候，我们首先将它与现有的日志集群块进行匹配（完全匹配或部分匹配），如果匹配失败了，就新建一个日志集群块来包含新到的这条日志。然后根据到达的日志消息更新日志集群的关联模板。</p><p>下面我们对完全匹配、部分匹配和不匹配进行详细说明。</p><ol><li><strong>完全匹配：</strong>我们将每个日志簇的模板视为正则表达式（例如，将&lt;*&gt;替换为 ”.**?“ ）来匹配给定的日志消息。这种方法允许模板匹配更长的日志消息，即使它们包含不同长度的参数，因为正则表达式允许匹配任何长度的标记。</li><li><strong>部分匹配：</strong>接下来，如果精确匹配失败，我们进行部分匹配。具体来说，我们对模板进行tokennize，并计算模板和候选日志消息之间的 Jaccard 相似度。如果候选日志与某个日志集块对应的模板的相似度大于0.5，就认为是部分匹配，否则就是不匹配。</li><li><strong>不匹配：</strong>如果叶节点中没有日志簇可以匹配给定的日志消息，我们在叶节点中创建一个新的日志簇（例如，C j &#x3D; (Lj , tj )）。这个新日志集群的模板是日志消息本身。</li></ol><p><strong>模板更新：</strong>如果给定的日志消息与某个日志集群块的模板匹配了，我们就把这个日志的ID加入到该日志集群块的$L_i$中，然后用日志$l_i$更新模板$t_i$，具体来说，我们首先识别 $l_i$ 和 $t_i$ 共享的公共token集。接下来，我们选择在 $t_i$ 和  $l_i$ 之间具有更多token的列表。最后，我们用占位符“&lt;*&gt;”替换较长列表中不在公共token集中的任何token。然后就产生了该日志集群块的新日志模板。</p><h3 id="4-Trie更新"><a href="#4-Trie更新" class="headerlink" title="4. Trie更新"></a>4. Trie更新</h3><p>在连续流中接收到的不同日志消息可能会导致模板提取不准确，因为在积累足够数量的日志消息之前可能会生成错误模板。反过来，这会影响精确匹配步骤和部分匹配步骤的准确性，从而产生更多错误的日志集群块。</p><p>为了解决这个问题，我们提出了一种自下而上的 Trie 更新方法，将共享相同模板的日志簇合并到单个簇中，并根据合并日志簇的新模板重建 Trie。</p><aside>💡 这一步不详细记录了，就是根据匹配规则合并一些相似的日志集群块，而且我感觉这个Trie更新这一步也是在实践中发现有这么个问题，然后找到的解决方法。</aside><h3 id="5-异常检测"><a href="#5-异常检测" class="headerlink" title="5. 异常检测"></a>5. 异常检测</h3><p>再经过了Trie结构之后，日志被处理成了模板，在以往的日志异常检测中，后面还需要进行特征提取和异常检测，会有额外的计算和维护成本。为了解决这个问题，我们提出了一个与 Trie 无缝集成的轻量级异常检测模块。</p><p><strong>我们的方法旨在通过检测出现频率显着低于其他模板的模板来识别异常。「本文做异常检测的核心」</strong></p><p>我们利用极值理论（EVT）框架中的广义极值（GEV）分布，它可以<strong>有效地识别大量值中的极值</strong>。具体来说，我们枚举每个日志簇，统计每个模板的出现次数，并生成计数列表 $L_{count} &#x3D; [x1, x2, …, xR]$，其中 $x_i$ 表示第 i 个模板的计数，R 是模版的数量。接下来，我们通过拟合 GEV 分布来应用 GEV 来检测 Lcount 中的异常情况。</p><p>使用KDD17paper（Anomaly Detection in Streams with Extreme Value Theory）中的GEV分布，首先得到每个日志集群块对应模板的GEV的累计分布函数值$f(x_i)$，然后根据所有日志模板的f值，求每个模板对应的异常分数，具体来说对每个日志模板对应的f值，首先计算所有分数t次方的总和 sum，然后用 该模板的 $f(x_i)^t &#x2F; sum$，就是该模板的异常分数。</p><p>当处理大量日志模板时，在拟合 GEV 分布时，整个日志簇集的计算成本可能会很高。为了解决这个问题，我们建议使用最近最少使用（LRU）策略来限制用于拟合分布的日志模板的数量。 LRU 策略维护最近看到的日志模板的缓存，并在缓存大小达到用户定义的大小 R（如公式 2 中使用）时丢弃最近最少使用的模板。 LRU 策略基于这样的观察：通常在较短的时间间隔（例如十分钟）内仅生成一小部分日志消息。因此，我们可以关注最近看到的日志模板，这些模板可能与该时间间隔内的异常检测相关。</p><h2 id="专家模块的工作流程"><a href="#专家模块的工作流程" class="headerlink" title="专家模块的工作流程"></a>专家模块的工作流程</h2><p>比较简单，上面的异常分数大于某个阈值，就交给专家处理</p><h2 id="ScaleAD和日志解析器Drain的关系"><a href="#ScaleAD和日志解析器Drain的关系" class="headerlink" title="ScaleAD和日志解析器Drain的关系"></a>ScaleAD和日志解析器Drain的关系</h2><p><img src="/articles/2023/10/15/%E6%97%A5%E5%BF%97%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/drain.png" alt="Drain的结构"></p><p>Drain是2017年的一篇关于日志解析的文章：Drain: An Online Log Parsing Approach with Fixed Depth Tree</p><p>翻译的文章<a href="https://zhuanlan.zhihu.com/p/627345347">在这里</a></p><p>可以看到，ScaleAD类似于Drain的结构，只有几点不同</p><ol><li>ScaleAD第一层采用的是INFO这种告警等级；Drain的第一层是一个长度信息</li><li>ScaleAD采用的是日志中出现最频繁的几个词；Drain第一层的节点采用的日志长度划分</li><li>对于到达每个叶子节点的日志，Drain主要将新日志与每个日志集群块的模板匹配是按照token的相似性；而ScalAD则是先简单粗暴地用正则表达式去匹配，不成功再用token的相似度进行匹配。</li></ol>]]></content>
    
    
    <categories>
      
      <category>日志异常检测</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志异常检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>证书验证机制实验记录</title>
    <link href="/articles/2022/11/22/certificate-work-record/"/>
    <url>/articles/2022/11/22/certificate-work-record/</url>
    
    <content type="html"><![CDATA[<h2 id="Ubuntu搭建Nginx服务器"><a href="#Ubuntu搭建Nginx服务器" class="headerlink" title="Ubuntu搭建Nginx服务器"></a>Ubuntu搭建Nginx服务器</h2><h3 id="step1-安装-Nginx"><a href="#step1-安装-Nginx" class="headerlink" title="step1 安装 Nginx"></a>step1 安装 Nginx</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure><h3 id="step2-调整防火墙"><a href="#step2-调整防火墙" class="headerlink" title="step2 调整防火墙"></a>step2 调整防火墙</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw app list # 查看状态</span><br><span class="line">sudo ufw allow &#x27;FULL&#x27;  # 调整防火墙，让他允许 Nginx的所有服务通过</span><br><span class="line">sudo ufw status # 查看更改结果</span><br></pre></td></tr></table></figure><h3 id="step3-检查web-服务器"><a href="#step3-检查web-服务器" class="headerlink" title="step3 检查web 服务器"></a>step3 检查web 服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status nginx</span><br></pre></td></tr></table></figure><p>然后就可以使用浏览器输入 <a href="http://your_ipaddress/">http://your_ipaddress</a> 来访问了</p><h3 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx  # 重启</span><br><span class="line"></span><br><span class="line">sudo systemctl reload nginx # 修改了配置之后重新加载</span><br><span class="line"></span><br><span class="line">sudo systemctl disable nginx # 默认情况下，Nginx 会在服务器启动时，跟随系统启动，如果我们不想这样，我们可以用这个命令来禁止</span><br><span class="line"></span><br><span class="line">sudo systemctl enable nginx # 要重新让系统启动时引导 Nginx 启动</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://kalacloud.com/blog/how-to-install-nginx-on-ubuntu-20-04/">https://kalacloud.com/blog/how-to-install-nginx-on-ubuntu-20-04/</a></p><p><a href="https://developer.aliyun.com/article/759280">https://developer.aliyun.com/article/759280</a></p><h2 id="Nginx安装SSL配置HTTPS"><a href="#Nginx安装SSL配置HTTPS" class="headerlink" title="Nginx安装SSL配置HTTPS"></a>Nginx安装SSL配置HTTPS</h2><p>看下面文章的第一部分，注意在覆盖文件之前先备份，防止出错</p><p><a href="https://segmentfault.com/a/1190000022673232">nginx - Nginx 安装 SSL 配置 HTTPS 超详细完整全过程_个人文章 - SegmentFault 思否</a></p><h2 id="生成证书并部署到Nginx服务器"><a href="#生成证书并部署到Nginx服务器" class="headerlink" title="生成证书并部署到Nginx服务器"></a>生成证书并部署到Nginx服务器</h2><p>使用下面命令后会让输入一些 地区、公司名、机构名之类的信息，随便写即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//生成ca 私钥</span><br><span class="line">openssl genrsa  -out ca.key 2048 </span><br><span class="line"> </span><br><span class="line">//生成ca证书</span><br><span class="line">openssl req -x509 -new -nodes -key ca.key -sha256 -days 3650 -out ca.crt</span><br><span class="line"> </span><br><span class="line">//生成server 私钥和证书请求文件</span><br><span class="line">openssl req -new -sha256 -nodes -out server.csr -newkey rsa:2048 -keyout server.key</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建v3.ext文件</span><br><span class="line">vim v3.ext</span><br><span class="line"></span><br><span class="line">// 在v3.ext文件中写入内容，注意换成IP</span><br><span class="line">//</span><br><span class="line">    authorityKeyIdentifier = keyid, issuer</span><br><span class="line">    basicConstraints = CA:FALSE</span><br><span class="line">    keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class="line">    subjectAltName = @alt_names</span><br><span class="line">    [alt_names]</span><br><span class="line">    DNS.1 = test.cn  //使用是ip 则使用IP.1=xxxx</span><br><span class="line">//</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用ca 签发server</span><br><span class="line">openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 3650 -sha256 -extfile v3.ext</span><br></pre></td></tr></table></figure><p>Nginx 配置，一般只需要修改生成证书的位置信息即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># HTTP_TO_HTTPS_END</span><br><span class="line">#ssl_password_file /etc/nginx/conf.d/openssl/global.pass;</span><br><span class="line">    ssl_certificate       /etc/nginx/conf.d/openssl/server.crt; # 只需要改这里</span><br><span class="line">    ssl_certificate_key   /etc/nginx/conf.d/openssl/server.key; # 只需要改这里</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    ssl_session_cache shared:SSL:10m;</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line">    error_page 497  https://$host$request_uri;</span><br><span class="line"># SSL-END</span><br></pre></td></tr></table></figure><p><mark>目前，<code>203.91.121.226</code>服务器上，证书生成的位置在<code>/etc/ssl/private/下面，nginx的配置文件可以通过</code>sudo nginx -t<code>进行查看，目前在</code> &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf&#96;中 </mark></p><p>每次<strong>修改完了nginx配置文件</strong></p><ul><li>使用 <code>nginx -t</code> 检查文件是否没问题</li><li>使用<code>nginx -s  reload</code> 重新加载配置文件</li></ul><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/LCRxxoo/article/details/120674063">https://blog.csdn.net/LCRxxoo/article/details/120674063</a> 【这篇最有效果】</p><p><a href="https://www.cnblogs.com/hukey/p/16306560.html">OpenSSL自签发CA证书chrome浏览器安全访问 - hukey - 博客园 (cnblogs.com)</a></p><h2 id="将根证书导入到浏览器中使其信任"><a href="#将根证书导入到浏览器中使其信任" class="headerlink" title="将根证书导入到浏览器中使其信任"></a>将根证书导入到浏览器中使其信任</h2><p>将上诉步骤生成的ca.crt导入浏览器即可</p><h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/hukey/p/16306560.html">OpenSSL自签发CA证书chrome浏览器安全访问 - hukey - 博客园 (cnblogs.com)</a></p><h2 id="使用hosts把自定义域名映射到本地"><a href="#使用hosts把自定义域名映射到本地" class="headerlink" title="使用hosts把自定义域名映射到本地"></a>使用hosts把自定义域名映射到本地</h2><p>Windows开发环境下，打开C:\Windows\System32\drivers\etc目录下的hosts文件。添加<code>127.0.0.1 jd.com</code>，完成IP地址（127.0.0.1）和域名（jd.com）映射的配置。如果修改后无法保存，请获得管理员权限后重试。</p><h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/307d9f91eede">https://www.jianshu.com/p/307d9f91eede</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>证书机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件分析课程实验-A1-活跃变量分析和迭代求解器</title>
    <link href="/articles/2022/11/20/static-analysis-A1/"/>
    <url>/articles/2022/11/20/static-analysis-A1/</url>
    
    <content type="html"><![CDATA[<p>课程主页：<a href="https://tai-e.pascal-lab.net/lectures.html">https://tai-e.pascal-lab.net/lectures.html</a></p><h2 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h2><p>数据流分析指的是一种用来获取有关数据如何沿着程序执行路径流动的相关技术，许多编译优化技术都依赖于数据流分析。</p><p>数据流分析有很多经典的应用，比如</p><ul><li>到达定值分析</li><li>活跃变量分析</li><li>可用表达式分析</li></ul><h2 id="活跃变量分析原理"><a href="#活跃变量分析原理" class="headerlink" title="活跃变量分析原理"></a>活跃变量分析原理</h2><p>活跃变量分析（Live Variable Analysis）是<strong>数据流分析</strong>的一个经典应用</p><h3 id="活跃变量"><a href="#活跃变量" class="headerlink" title="活跃变量"></a><strong>活跃变量</strong></h3><p>对于变量$x$和程序点$p$，如果在程序流图中沿着从$p$开始的<strong>某条路径</strong>会引用变量$x$在$p$点的值，则称变量$x$在点$p$是活跃（live）的，否则称变量$x$在点$p$是不活跃（dead）的</p><h3 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a><strong>主要用途</strong></h3><ol><li>删除无用赋值：如果在某点赋值，但是后面又不会用到的话，可以将该点的赋值删除</li><li>寄存器分配：如果寄存器都被占用，则当再次申请寄存器的时候，需要替换掉一些占用寄存器的变量。通过活跃变量分析，可以将不活跃变量所占用的寄存器空出来</li></ol><h3 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a><strong>符号定义</strong></h3><p>$def_B, use_B, IN[B], OUT[B]$</p><ul><li>$def_B$ ： <strong>赋值先于任何使用</strong>的变量的集合</li><li>$use_B$：  <strong>使用先于任何赋值</strong>的变量的集合</li><li>$IN[B], OUT[B]$： 分别表示在<strong>紧靠一个基本块$B$之前和之后的点上</strong>的活跃变量的集合</li></ul><p>比如对于下面$B_2$ 的基本块中，对于 $i &#x3D; i + 1;$ 这条语句可以拆分成$t &#x3D; i + 1; i &#x3D; t;$两条指令，所以对于变量$i$而言，其使用先于任何赋值，所以属于$use_{B_2}$ 中的变量，不属于$def_{B_2}$中的变量。</p><p>另一个例子是，对于一个基本块中如果有两条指令：$v&#x3D;2; k &#x3D;  v;$ 则变量$v$的赋值先于其任何的使用，所以变量$v$属于$def_B$，而不属于 $use_B$。</p><blockquote><p>根据这些定义，$use_B$中的任何变量都必然被认为在基本块$B$的入口处是活跃的，而$def_B$中所有的变量在B的开头一定是不活跃的。</p><p>实际上，$def_b$中的成员“杀死了”某个变量可能从$B$开始成为活跃变量的任何机会</p><p>《编译原理 第二版》P390</p></blockquote><p><img src="/articles/2022/11/20/static-analysis-A1/fig2.jpg" alt="fig2"></p><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a><strong>算法原理</strong></h3><p><img src="/articles/2022/11/20/static-analysis-A1/fig3.jpg" alt="fig3"></p><ul><li>$IN[EXIT] &#x3D; \emptyset$  ： 边界条件，表示<strong>程序出口处没有变量是活跃的</strong></li><li>然后对所有除了$EXIT$ 之外的基本块 $B$ 来说，首先初始化所有$B$为空集 $IN[B] &#x3D; \emptyset$，初始化之后对所有的$B$执行如下的<strong>转移函数</strong><ul><li>$OUT[B] &#x3D; \cup _{S是B的一个后继} IN[S]$ ：一个变量在离开一个基本块的时候活跃，当且仅当它进入该基本块的<strong>某个后继</strong>时活跃</li><li>$IN[B] &#x3D; use_B \cup(OUT[B] - def_B)$ ：一个变量进入基本块的时候活跃必须保证 ，要么<strong>在基本块中被赋值之前就使用了</strong>，要么<strong>在离开基本块的时候活跃并且没有对它重新赋值</strong></li></ul></li></ul><h2 id="A1实验分析"><a href="#A1实验分析" class="headerlink" title="A1实验分析"></a>A1实验分析</h2><h3 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h3><p>本次作业需要实现一个活跃变量分析算法，抽象的算法如下图所示，具体而言，需要求出每个基本块的InFact值，里面包含该点所有的活跃变量。本次作业需要填空来完成下图的算法实现</p><p><img src="/articles/2022/11/20/static-analysis-A1/iter-alg.png" alt="Iterative Algorithm"></p><p>需要注意：</p><ul><li>本次作业的每个基本块仅含有一条指令</li><li>实验的结果最后存储在参数 <code>DataflowResult&lt;Node, Fact&gt; result</code>中</li><li>用到了Java的一些特性<ul><li>Optional特性：isPresent() 和 get()的使用</li><li>泛型特性</li></ul></li></ul><h3 id="step1-初始化基本块的-InFact和OutFact"><a href="#step1-初始化基本块的-InFact和OutFact" class="headerlink" title="step1: 初始化基本块的 InFact和OutFact"></a>step1: 初始化基本块的 InFact和OutFact</h3><p><code>pascal/taie/analysis/dataflow/analysis/LiveVariableAnalysis.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> SetFact&lt;Var&gt; <span class="title function_">newBoundaryFact</span><span class="params">(CFG&lt;Stmt&gt; cfg)</span> &#123;</span><br><span class="line">       <span class="comment">// TODO - finish me</span></span><br><span class="line">       <span class="comment">// 返回边界节点的向量，backwards的边界节点是 exit节点</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SetFact</span>&lt;Var&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> SetFact&lt;Var&gt; <span class="title function_">newInitialFact</span><span class="params">()</span> &#123;  <span class="comment">// 返回值就是 SetFact&lt;Var&gt;</span></span><br><span class="line">       <span class="comment">// TODO - finish me</span></span><br><span class="line">       <span class="comment">// 除了exit节点的其他节点初始化为空</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SetFact</span>&lt;Var&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetInto</span><span class="params">(SetFact&lt;Var&gt; fact, SetFact&lt;Var&gt; target)</span> &#123; <span class="comment">// 注意这里提示了，使用的是SetFact&lt;Var&gt;， 所以前面用的也都是Var</span></span><br><span class="line">       <span class="comment">// TODO - finish me</span></span><br><span class="line">       <span class="comment">// 并起来</span></span><br><span class="line">       target.union(fact);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>pascal/taie/analysis/dataflow/solver/Solver.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initializeBackward</span><span class="params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO - finish me</span></span><br><span class="line">    <span class="comment">// step1 将 exit节点的InFact置为空集</span></span><br><span class="line">    result.setInFact(cfg.getExit(), analysis.newBoundaryFact(cfg));</span><br><span class="line">    <span class="comment">// step2 将 除了exit节点之外的其他节点的InFact和OutFact置为空集</span></span><br><span class="line">    <span class="keyword">for</span> (Node node : cfg.getNodes()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cfg.isExit(node)) <span class="keyword">continue</span>;</span><br><span class="line">        result.setInFact(node, analysis.newInitialFact());</span><br><span class="line">        <span class="comment">// 将OutFact也置为空集</span></span><br><span class="line">        result.setOutFact(node, analysis.newInitialFact());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step2-实现迭代求解器"><a href="#step2-实现迭代求解器" class="headerlink" title="step2: 实现迭代求解器"></a>step2: 实现迭代求解器</h3><p><code>pascal/taie/analysis/dataflow/solver/IterativeSolver.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doSolveBackward</span><span class="params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO - finish me</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (changed) &#123;</span><br><span class="line">        changed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Node node : cfg.getNodes()) &#123;</span><br><span class="line">            <span class="comment">// 除了exit的Node，因为exitNode没有outFact</span></span><br><span class="line">            <span class="keyword">if</span> (cfg.isExit(node)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 求出OutFact</span></span><br><span class="line">            <span class="keyword">for</span> (Node succNode : cfg.getSuccsOf(node)) &#123;</span><br><span class="line">                analysis.meetInto(result.getInFact(succNode), result.getOutFact(node));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用outfact做转换，得到infact</span></span><br><span class="line">            <span class="comment">// 并且查看是否这个block的状态是否改变了</span></span><br><span class="line">            <span class="keyword">if</span> (analysis.transferNode(node, result.getInFact(node), result.getOutFact(node))) changed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step3-实现转换函数"><a href="#step3-实现转换函数" class="headerlink" title="step3: 实现转换函数"></a>step3: 实现转换函数</h3><p><code>pascal/taie/analysis/dataflow/analysis/LiveVariableAnalysis.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transferNode</span><span class="params">(Stmt stmt, SetFact&lt;Var&gt; in, SetFact&lt;Var&gt; out)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO - finish me</span></span><br><span class="line">    <span class="comment">// 复制outFact，求出新的inFact</span></span><br><span class="line">    SetFact&lt;Var&gt; newInFact = <span class="keyword">new</span> <span class="title class_">SetFact</span>&lt;&gt;();</span><br><span class="line">    newInFact.union(out);</span><br><span class="line">    <span class="comment">// 求出新的inFact</span></span><br><span class="line">    <span class="comment">// outFact - def</span></span><br><span class="line">    <span class="keyword">if</span> (stmt.getDef().isPresent()) &#123; <span class="comment">// 先用isPresent再用get是optional的典型用法</span></span><br><span class="line">        <span class="type">LValue</span> <span class="variable">def</span> <span class="operator">=</span> stmt.getDef().get();</span><br><span class="line">        <span class="keyword">if</span> (def <span class="keyword">instanceof</span> Var) &#123;</span><br><span class="line">            newInFact.remove((Var) def);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// (outFact - def ) + use</span></span><br><span class="line">    <span class="keyword">for</span> (RValue use : stmt.getUses()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (use <span class="keyword">instanceof</span>  Var) &#123;</span><br><span class="line">            newInFact.add((Var) use);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断inFact是否改变，并返回Boolean表示</span></span><br><span class="line">    <span class="keyword">if</span> (!newInFact.equals(in)) &#123;</span><br><span class="line">        in.set(newInFact);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>编译原理，第二版（龙书）</p><p><a href="https://leiblog.wang/%E7%BC%96%E8%AF%91%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BD%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#">超棒的博客，这个人是搞编译器的，他的博客可以看看</a></p><p><a href="https://www.jianshu.com/p/ebc1c72b881c">这个人的博客写了很多关于编译器优化的总结</a> </p><p><a href="https://liuyehcf.github.io/2017/11/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%963/">活跃变量分析 &amp; 常用表达式分析</a></p><p><a href="https://www.bilibili.com/video/BV1zW411t7YE/?vd_source=ee07a5a150ae217eba28dd2c4bd5549b">编译原理-哈工大，上面博客的课件都来自于此</a></p><p><a href="https://blog.csdn.net/weixin_43258309/article/details/104512206">数据流分析应用总结</a></p>]]></content>
    
    
    <categories>
      
      <category>静态程序分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>github+hexo博客上传图片无法显示</title>
    <link href="/articles/2022/10/17/how-to-upload-image-to-github-io/"/>
    <url>/articles/2022/10/17/how-to-upload-image-to-github-io/</url>
    
    <content type="html"><![CDATA[<p>github+hexo博客上传图片无法显示</p><p><strong>解决方法：</strong></p><ol><li>用f12查看图片的链接，发现链接是带日期的，而<code>hexo new post &quot;xxx&quot;</code>创建的md文件都是直接放到_post里面了，所以需要修改默认生成md的位置到 <code>年/月/日/xx.md</code>里面</li></ol><p>​<img src="/articles/2022/10/17/how-to-upload-image-to-github-io/image.png"></p><p>​所以将<code>_config.yml</code>中的<code>permalink</code>修改为： <code>permalink: &#39;articles/:year/:month/:day/:name/&#39;</code></p><ol start="2"><li><p>而且md插入图片的时候，不要加相对链接，直接写图片名字（虽然这样会导致本地的md文件不能现实图片）</p><p><img src="/articles/2022/10/17/how-to-upload-image-to-github-io/image-20221017165402267.png"></p></li></ol><p><strong>参考链接：</strong></p><p><a href="https://blog.csdn.net/m0_43401436/article/details/107191688">https://blog.csdn.net/m0_43401436/article/details/107191688</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
