<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>证书验证机制实验记录</title>
    <link href="/articles/2022/11/22/certificate-work-record/"/>
    <url>/articles/2022/11/22/certificate-work-record/</url>
    
    <content type="html"><![CDATA[<h2 id="Ubuntu搭建Nginx服务器"><a href="#Ubuntu搭建Nginx服务器" class="headerlink" title="Ubuntu搭建Nginx服务器"></a>Ubuntu搭建Nginx服务器</h2><h3 id="step1-安装-Nginx"><a href="#step1-安装-Nginx" class="headerlink" title="step1 安装 Nginx"></a>step1 安装 Nginx</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure><h3 id="step2-调整防火墙"><a href="#step2-调整防火墙" class="headerlink" title="step2 调整防火墙"></a>step2 调整防火墙</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw app list # 查看状态</span><br><span class="line">sudo ufw allow &#x27;FULL&#x27;  # 调整防火墙，让他允许 Nginx的所有服务通过</span><br><span class="line">sudo ufw status # 查看更改结果</span><br></pre></td></tr></table></figure><h3 id="step3-检查web-服务器"><a href="#step3-检查web-服务器" class="headerlink" title="step3 检查web 服务器"></a>step3 检查web 服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status nginx</span><br></pre></td></tr></table></figure><p>然后就可以使用浏览器输入 <a href="http://your_ipaddress/">http://your_ipaddress</a> 来访问了</p><h3 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx  # 重启</span><br><span class="line"></span><br><span class="line">sudo systemctl reload nginx # 修改了配置之后重新加载</span><br><span class="line"></span><br><span class="line">sudo systemctl disable nginx # 默认情况下，Nginx 会在服务器启动时，跟随系统启动，如果我们不想这样，我们可以用这个命令来禁止</span><br><span class="line"></span><br><span class="line">sudo systemctl enable nginx # 要重新让系统启动时引导 Nginx 启动</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://kalacloud.com/blog/how-to-install-nginx-on-ubuntu-20-04/">https://kalacloud.com/blog/how-to-install-nginx-on-ubuntu-20-04/</a></p><p><a href="https://developer.aliyun.com/article/759280">https://developer.aliyun.com/article/759280</a></p><h2 id="Nginx安装SSL配置HTTPS"><a href="#Nginx安装SSL配置HTTPS" class="headerlink" title="Nginx安装SSL配置HTTPS"></a>Nginx安装SSL配置HTTPS</h2><p>看下面文章的第一部分，注意在覆盖文件之前先备份，防止出错</p><p><a href="https://segmentfault.com/a/1190000022673232">nginx - Nginx 安装 SSL 配置 HTTPS 超详细完整全过程_个人文章 - SegmentFault 思否</a></p><h2 id="生成证书并部署到Nginx服务器"><a href="#生成证书并部署到Nginx服务器" class="headerlink" title="生成证书并部署到Nginx服务器"></a>生成证书并部署到Nginx服务器</h2><p>使用下面命令后会让输入一些 地区、公司名、机构名之类的信息，随便写即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//生成ca 私钥</span><br><span class="line">openssl genrsa  -out ca.key 2048 </span><br><span class="line"> </span><br><span class="line">//生成ca证书</span><br><span class="line">openssl req -x509 -new -nodes -key ca.key -sha256 -days 3650 -out ca.crt</span><br><span class="line"> </span><br><span class="line">//生成server 私钥和证书请求文件</span><br><span class="line">openssl req -new -sha256 -nodes -out server.csr -newkey rsa:2048 -keyout server.key</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建v3.ext文件</span><br><span class="line">vim v3.ext</span><br><span class="line"></span><br><span class="line">// 在v3.ext文件中写入内容，注意换成IP</span><br><span class="line">//</span><br><span class="line">    authorityKeyIdentifier = keyid, issuer</span><br><span class="line">    basicConstraints = CA:FALSE</span><br><span class="line">    keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class="line">    subjectAltName = @alt_names</span><br><span class="line">    [alt_names]</span><br><span class="line">    DNS.1 = test.cn  //使用是ip 则使用IP.1=xxxx</span><br><span class="line">//</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用ca 签发server</span><br><span class="line">openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 3650 -sha256 -extfile v3.ext</span><br></pre></td></tr></table></figure><p>Nginx 配置，一般只需要修改生成证书的位置信息即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># HTTP_TO_HTTPS_END</span><br><span class="line">#ssl_password_file /etc/nginx/conf.d/openssl/global.pass;</span><br><span class="line">    ssl_certificate       /etc/nginx/conf.d/openssl/server.crt; # 只需要改这里</span><br><span class="line">    ssl_certificate_key   /etc/nginx/conf.d/openssl/server.key; # 只需要改这里</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    ssl_session_cache shared:SSL:10m;</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line">    error_page 497  https://$host$request_uri;</span><br><span class="line"># SSL-END</span><br></pre></td></tr></table></figure><p><mark>目前，<code>203.91.121.226</code>服务器上，证书生成的位置在<code>/etc/ssl/private/下面，nginx的配置文件可以通过</code>sudo nginx -t<code>进行查看，目前在</code> &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf&#96;中 </mark></p><p>每次<strong>修改完了nginx配置文件</strong></p><ul><li>使用 <code>nginx -t</code> 检查文件是否没问题</li><li>使用<code>nginx -s  reload</code> 重新加载配置文件</li></ul><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/LCRxxoo/article/details/120674063">https://blog.csdn.net/LCRxxoo/article/details/120674063</a> 【这篇最有效果】</p><p><a href="https://www.cnblogs.com/hukey/p/16306560.html">OpenSSL自签发CA证书chrome浏览器安全访问 - hukey - 博客园 (cnblogs.com)</a></p><h2 id="将根证书导入到浏览器中使其信任"><a href="#将根证书导入到浏览器中使其信任" class="headerlink" title="将根证书导入到浏览器中使其信任"></a>将根证书导入到浏览器中使其信任</h2><p>将上诉步骤生成的ca.crt导入浏览器即可</p><h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/hukey/p/16306560.html">OpenSSL自签发CA证书chrome浏览器安全访问 - hukey - 博客园 (cnblogs.com)</a></p><h2 id="使用hosts把自定义域名映射到本地"><a href="#使用hosts把自定义域名映射到本地" class="headerlink" title="使用hosts把自定义域名映射到本地"></a>使用hosts把自定义域名映射到本地</h2><p>Windows开发环境下，打开C:\Windows\System32\drivers\etc目录下的hosts文件。添加<code>127.0.0.1 jd.com</code>，完成IP地址（127.0.0.1）和域名（jd.com）映射的配置。如果修改后无法保存，请获得管理员权限后重试。</p><h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/307d9f91eede">https://www.jianshu.com/p/307d9f91eede</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>证书机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件分析课程实验-A1-活跃变量分析和迭代求解器</title>
    <link href="/articles/2022/11/20/static-analysis-A1/"/>
    <url>/articles/2022/11/20/static-analysis-A1/</url>
    
    <content type="html"><![CDATA[<p>课程主页：<a href="https://tai-e.pascal-lab.net/lectures.html">https://tai-e.pascal-lab.net/lectures.html</a></p><h2 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h2><p>数据流分析指的是一种用来获取有关数据如何沿着程序执行路径流动的相关技术，许多编译优化技术都依赖于数据流分析。</p><p>数据流分析有很多经典的应用，比如</p><ul><li>到达定值分析</li><li>活跃变量分析</li><li>可用表达式分析</li></ul><h2 id="活跃变量分析原理"><a href="#活跃变量分析原理" class="headerlink" title="活跃变量分析原理"></a>活跃变量分析原理</h2><p>活跃变量分析（Live Variable Analysis）是<strong>数据流分析</strong>的一个经典应用</p><h3 id="活跃变量"><a href="#活跃变量" class="headerlink" title="活跃变量"></a><strong>活跃变量</strong></h3><p>对于变量$x$和程序点$p$，如果在程序流图中沿着从$p$开始的<strong>某条路径</strong>会引用变量$x$在$p$点的值，则称变量$x$在点$p$是活跃（live）的，否则称变量$x$在点$p$是不活跃（dead）的</p><h3 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a><strong>主要用途</strong></h3><ol><li>删除无用赋值：如果在某点赋值，但是后面又不会用到的话，可以将该点的赋值删除</li><li>寄存器分配：如果寄存器都被占用，则当再次申请寄存器的时候，需要替换掉一些占用寄存器的变量。通过活跃变量分析，可以将不活跃变量所占用的寄存器空出来</li></ol><h3 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a><strong>符号定义</strong></h3><p>$def_B, use_B, IN[B], OUT[B]$</p><ul><li>$def_B$ ： <strong>赋值先于任何使用</strong>的变量的集合</li><li>$use_B$：  <strong>使用先于任何赋值</strong>的变量的集合</li><li>$IN[B], OUT[B]$： 分别表示在<strong>紧靠一个基本块$B$之前和之后的点上</strong>的活跃变量的集合</li></ul><p>比如对于下面$B_2$ 的基本块中，对于 $i &#x3D; i + 1;$ 这条语句可以拆分成$t &#x3D; i + 1; i &#x3D; t;$两条指令，所以对于变量$i$而言，其使用先于任何赋值，所以属于$use_{B_2}$ 中的变量，不属于$def_{B_2}$中的变量。</p><p>另一个例子是，对于一个基本块中如果有两条指令：$v&#x3D;2; k &#x3D;  v;$ 则变量$v$的赋值先于其任何的使用，所以变量$v$属于$def_B$，而不属于 $use_B$。</p><blockquote><p>根据这些定义，$use_B$中的任何变量都必然被认为在基本块$B$的入口处是活跃的，而$def_B$中所有的变量在B的开头一定是不活跃的。</p><p>实际上，$def_b$中的成员“杀死了”某个变量可能从$B$开始成为活跃变量的任何机会</p><p>《编译原理 第二版》P390</p></blockquote><p><img src="/articles/2022/11/20/static-analysis-A1/fig2.jpg" alt="fig2"></p><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a><strong>算法原理</strong></h3><p><img src="/articles/2022/11/20/static-analysis-A1/fig3.jpg" alt="fig3"></p><ul><li>$IN[EXIT] &#x3D; \emptyset$  ： 边界条件，表示<strong>程序出口处没有变量是活跃的</strong></li><li>然后对所有除了$EXIT$ 之外的基本块 $B$ 来说，首先初始化所有$B$为空集 $IN[B] &#x3D; \emptyset$，初始化之后对所有的$B$执行如下的<strong>转移函数</strong><ul><li>$OUT[B] &#x3D; \cup _{S是B的一个后继} IN[S]$ ：一个变量在离开一个基本块的时候活跃，当且仅当它进入该基本块的<strong>某个后继</strong>时活跃</li><li>$IN[B] &#x3D; use_B \cup(OUT[B] - def_B)$ ：一个变量进入基本块的时候活跃必须保证 ，要么<strong>在基本块中被赋值之前就使用了</strong>，要么<strong>在离开基本块的时候活跃并且没有对它重新赋值</strong></li></ul></li></ul><h2 id="A1实验分析"><a href="#A1实验分析" class="headerlink" title="A1实验分析"></a>A1实验分析</h2><h3 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h3><p>本次作业需要实现一个活跃变量分析算法，抽象的算法如下图所示，具体而言，需要求出每个基本块的InFact值，里面包含该点所有的活跃变量。本次作业需要填空来完成下图的算法实现</p><p><img src="/articles/2022/11/20/static-analysis-A1/iter-alg.png" alt="Iterative Algorithm"></p><p>需要注意：</p><ul><li>本次作业的每个基本块仅含有一条指令</li><li>实验的结果最后存储在参数 <code>DataflowResult&lt;Node, Fact&gt; result</code>中</li><li>用到了Java的一些特性<ul><li>Optional特性：isPresent() 和 get()的使用</li><li>泛型特性</li></ul></li></ul><h3 id="step1-初始化基本块的-InFact和OutFact"><a href="#step1-初始化基本块的-InFact和OutFact" class="headerlink" title="step1: 初始化基本块的 InFact和OutFact"></a>step1: 初始化基本块的 InFact和OutFact</h3><p><code>pascal/taie/analysis/dataflow/analysis/LiveVariableAnalysis.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> SetFact&lt;Var&gt; <span class="title function_">newBoundaryFact</span><span class="params">(CFG&lt;Stmt&gt; cfg)</span> &#123;</span><br><span class="line">       <span class="comment">// TODO - finish me</span></span><br><span class="line">       <span class="comment">// 返回边界节点的向量，backwards的边界节点是 exit节点</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SetFact</span>&lt;Var&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> SetFact&lt;Var&gt; <span class="title function_">newInitialFact</span><span class="params">()</span> &#123;  <span class="comment">// 返回值就是 SetFact&lt;Var&gt;</span></span><br><span class="line">       <span class="comment">// TODO - finish me</span></span><br><span class="line">       <span class="comment">// 除了exit节点的其他节点初始化为空</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SetFact</span>&lt;Var&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetInto</span><span class="params">(SetFact&lt;Var&gt; fact, SetFact&lt;Var&gt; target)</span> &#123; <span class="comment">// 注意这里提示了，使用的是SetFact&lt;Var&gt;， 所以前面用的也都是Var</span></span><br><span class="line">       <span class="comment">// TODO - finish me</span></span><br><span class="line">       <span class="comment">// 并起来</span></span><br><span class="line">       target.union(fact);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>pascal/taie/analysis/dataflow/solver/Solver.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initializeBackward</span><span class="params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO - finish me</span></span><br><span class="line">    <span class="comment">// step1 将 exit节点的InFact置为空集</span></span><br><span class="line">    result.setInFact(cfg.getExit(), analysis.newBoundaryFact(cfg));</span><br><span class="line">    <span class="comment">// step2 将 除了exit节点之外的其他节点的InFact和OutFact置为空集</span></span><br><span class="line">    <span class="keyword">for</span> (Node node : cfg.getNodes()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cfg.isExit(node)) <span class="keyword">continue</span>;</span><br><span class="line">        result.setInFact(node, analysis.newInitialFact());</span><br><span class="line">        <span class="comment">// 将OutFact也置为空集</span></span><br><span class="line">        result.setOutFact(node, analysis.newInitialFact());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step2-实现迭代求解器"><a href="#step2-实现迭代求解器" class="headerlink" title="step2: 实现迭代求解器"></a>step2: 实现迭代求解器</h3><p><code>pascal/taie/analysis/dataflow/solver/IterativeSolver.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doSolveBackward</span><span class="params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO - finish me</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (changed) &#123;</span><br><span class="line">        changed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Node node : cfg.getNodes()) &#123;</span><br><span class="line">            <span class="comment">// 除了exit的Node，因为exitNode没有outFact</span></span><br><span class="line">            <span class="keyword">if</span> (cfg.isExit(node)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 求出OutFact</span></span><br><span class="line">            <span class="keyword">for</span> (Node succNode : cfg.getSuccsOf(node)) &#123;</span><br><span class="line">                analysis.meetInto(result.getInFact(succNode), result.getOutFact(node));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用outfact做转换，得到infact</span></span><br><span class="line">            <span class="comment">// 并且查看是否这个block的状态是否改变了</span></span><br><span class="line">            <span class="keyword">if</span> (analysis.transferNode(node, result.getInFact(node), result.getOutFact(node))) changed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step3-实现转换函数"><a href="#step3-实现转换函数" class="headerlink" title="step3: 实现转换函数"></a>step3: 实现转换函数</h3><p><code>pascal/taie/analysis/dataflow/analysis/LiveVariableAnalysis.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transferNode</span><span class="params">(Stmt stmt, SetFact&lt;Var&gt; in, SetFact&lt;Var&gt; out)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO - finish me</span></span><br><span class="line">    <span class="comment">// 复制outFact，求出新的inFact</span></span><br><span class="line">    SetFact&lt;Var&gt; newInFact = <span class="keyword">new</span> <span class="title class_">SetFact</span>&lt;&gt;();</span><br><span class="line">    newInFact.union(out);</span><br><span class="line">    <span class="comment">// 求出新的inFact</span></span><br><span class="line">    <span class="comment">// outFact - def</span></span><br><span class="line">    <span class="keyword">if</span> (stmt.getDef().isPresent()) &#123; <span class="comment">// 先用isPresent再用get是optional的典型用法</span></span><br><span class="line">        <span class="type">LValue</span> <span class="variable">def</span> <span class="operator">=</span> stmt.getDef().get();</span><br><span class="line">        <span class="keyword">if</span> (def <span class="keyword">instanceof</span> Var) &#123;</span><br><span class="line">            newInFact.remove((Var) def);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// (outFact - def ) + use</span></span><br><span class="line">    <span class="keyword">for</span> (RValue use : stmt.getUses()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (use <span class="keyword">instanceof</span>  Var) &#123;</span><br><span class="line">            newInFact.add((Var) use);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断inFact是否改变，并返回Boolean表示</span></span><br><span class="line">    <span class="keyword">if</span> (!newInFact.equals(in)) &#123;</span><br><span class="line">        in.set(newInFact);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>编译原理，第二版（龙书）</p><p><a href="https://leiblog.wang/%E7%BC%96%E8%AF%91%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BD%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#">超棒的博客，这个人是搞编译器的，他的博客可以看看</a></p><p><a href="https://www.jianshu.com/p/ebc1c72b881c">这个人的博客写了很多关于编译器优化的总结</a> </p><p><a href="https://liuyehcf.github.io/2017/11/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%963/">活跃变量分析 &amp; 常用表达式分析</a></p><p><a href="https://www.bilibili.com/video/BV1zW411t7YE/?vd_source=ee07a5a150ae217eba28dd2c4bd5549b">编译原理-哈工大，上面博客的课件都来自于此</a></p><p><a href="https://blog.csdn.net/weixin_43258309/article/details/104512206">数据流分析应用总结</a></p>]]></content>
    
    
    <categories>
      
      <category>静态程序分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>少就是多，慢就是快</title>
    <link href="/articles/2022/10/19/focus-on-one-thing-over-a-period-time/"/>
    <url>/articles/2022/10/19/focus-on-one-thing-over-a-period-time/</url>
    
    <content type="html"><![CDATA[<h2 id="“少就是多，慢就是快”"><a href="#“少就是多，慢就是快”" class="headerlink" title="“少就是多，慢就是快”"></a>“少就是多，慢就是快”</h2><blockquote><p> 我很喜欢这几个字。 这几个字很容易理解，但我还是解释一下：一个时间范围内，不要贪心搞很多事情，专注一个方向，足够的付出，结果自然会很”快”和很“多”。</p><p>摘抄自：<a href="https://github.com/zhuifengshaonianhanlu/pikachu">https://github.com/zhuifengshaonianhanlu/pikachu</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>摘抄</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>github+hexo博客上传图片无法显示</title>
    <link href="/articles/2022/10/17/how-to-upload-image-to-github-io/"/>
    <url>/articles/2022/10/17/how-to-upload-image-to-github-io/</url>
    
    <content type="html"><![CDATA[<p>github+hexo博客上传图片无法显示</p><p><strong>解决方法：</strong></p><ol><li>用f12查看图片的链接，发现链接是带日期的，而<code>hexo new post &quot;xxx&quot;</code>创建的md文件都是直接放到_post里面了，所以需要修改默认生成md的位置到 <code>年/月/日/xx.md</code>里面</li></ol><p>​<img src="/articles/2022/10/17/how-to-upload-image-to-github-io/image.png"></p><p>​所以将<code>_config.yml</code>中的<code>permalink</code>修改为： <code>permalink: &#39;articles/:year/:month/:day/:name/&#39;</code></p><ol start="2"><li><p>而且md插入图片的时候，不要加相对链接，直接写图片名字（虽然这样会导致本地的md文件不能现实图片）</p><p><img src="/articles/2022/10/17/how-to-upload-image-to-github-io/image-20221017165402267.png"></p></li></ol><p><strong>参考链接：</strong></p><p><a href="https://blog.csdn.net/m0_43401436/article/details/107191688">https://blog.csdn.net/m0_43401436/article/details/107191688</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>hexo+github建设个人blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
